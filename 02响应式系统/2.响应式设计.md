
## Reactive
`reactive`核心是返回的是**响应式代理**， 
关注**数据内部属性**的变更，内部使用Proxy拦截对对象的操作，从而实现响应式

```js
function reactive(target) {
	return createReactiveObject(
		target,
		traps
	)
}

function createReactiveObject(target, traps) {
	return new Proxy(target, traps)
}

// traps 里面是根据不同类型target，传入不同的traps函数，用以拦截不同类型的对象操作，object、array、map、set、 weakMap、weakSet
```


## Ref
`ref`核心是返回**响应式且可变的引用对象实例** 是一个Ref类的实例
关注数据整体的变更，
数据整体的响应式，是通过getter、setter实现的
数据属性的响应式，还是依赖reactive

```js
function ref(rawValue) {
	return createRef(rawValue)
}

function createRef(rawValue) {
	return new RefImpl(rawValue)
}

class RefImpl {
	constructor(value) {
		this.raw = toRaw(value)
		this._value = toReactive(value) 
	}

	get value() {
		trackRefValue() // 依赖收集
		retrun this._value
	}

	set value() {
		this._value = toReactive(value)
		triggerRefValue() // 触发响应
	}
}

function toReactive(value) {
	// ref对象的value值，对象的话是reactive响应式数据，基本值的话是初始值
	return isObject(value) ? reactive(value) : value
}
```

## Effect
`effect(fn)`
fn 副作用函数,在响应式系统里面，在数据变更时需要重新执行的逻辑

> 副作用函数，在函数式编程里面，相对于纯函数的存在
> 会改变全局状态或者公共状态，影响其他函数的执行结果

`effect()` 是将状态与副作用函数建立关联的地方

在vue中，最常见的副作用函数就是 dom 操作
vue把组件的template编译成 render函数，作为组件状态的副作用函数，在组件状态发生变化的时候，执行render函数，更新dom

另一个常见的例子是，`watchEffect()` 
当组件内有一批操作都是依赖共同的状态变更时，可以将这些操作放在`watchEffect()` 里面，这样当状态变更时，会自动重新执行所有的操作

本质上，响应式系统就是古老的`可观察/订阅者模式`的现代版本
响应式数据是可观察者；
副作用函数是订阅者

可观察/订阅模式，无法避免的一个问题就是：
订阅必然伴随着注销，否则会存在内存泄漏问题

在vue中，正常情况下，开发者不需要考虑，因为vue做了这部分工作，所有的响应式都是关联着组件生命周期，在组件创建时发起订阅，在组件销毁时，注销订阅。 观察/订阅的建立、销毁与组件生命周期绑定，是通过scopeEffect建立的。

但是vue的响应式系统是模块化的，可以单独使用，
独立于组件使用响应式数据时，就需要开发者手动处理注销订阅
这个就是`effectScope`api存在的另一个意义


## References
+ [understand effectScope](https://stackoverflow.com/questions/70493794/how-to-understand-the-effectscope-in-vue)